<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>本地批量裁剪 1:1 / 3:4 → 导出JPEG（适配 Temu）</title>
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet">
  <style>
    :root{--accent:#111827;--accent-2:#374151;--border:#e5e7eb;--bg:#f3f4f6;}
    *{box-sizing:border-box}
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #111827; color: #fff; }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 16px; padding: 16px; }
    .panel { border: 1px solid var(--border); border-radius: 8px; padding: 12px; background:#fff; }
    .thumbs { display: grid; grid-template-columns: repeat(auto-fill, minmax(88px,1fr)); gap: 8px; max-height: 60vh; overflow: auto; }
    .thumb { position:relative; border: 2px solid transparent; border-radius: 6px; padding: 2px; cursor: pointer; background:#f9fafb; }
    .thumb.active { border-color: #3b82f6; background:#eff6ff; }
    .thumb img { width: 100%; display: block; border-radius: 4px; }
    .thumb .close {position:absolute; right:4px; top:4px; width:20px; height:20px; line-height:18px; text-align:center; border-radius:10px; background:#111827; color:#fff; font-weight:700; font-size:12px; display:none; cursor:pointer;}
    .thumb:hover .close{display:block;}
    .controls label { display:block; font-size: 13px; margin-top: 8px; }
    .controls input[type="text"], .controls input[type="number"], .controls select { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #d1d5db; }
    .controls .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .btn { display:inline-flex; align-items:center; gap:6px; background:var(--accent); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:var(--accent-2); }
    .btn[disabled] { opacity:.5; cursor:not-allowed; }
    #canvasWrap { display:flex; align-items:center; justify-content:center; height: 70vh; background:var(--bg); border-radius:8px; overflow:hidden; border:1px dashed var(--border); }
    #previewImg { max-width:100%; max-height:100%; }
    footer { padding: 12px 16px; color:#6b7280; font-size:12px; }
    .bar { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .hint { font-size: 12px; color:#cbd5e1; }
    .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:14px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; font-size:13px; opacity:0; transition:opacity .2s, transform .2s;}
    .toast.show{opacity:1; transform:translate(-50%,-6px)}
    .muted{color:#6b7280; font-size:12px}
    .drop-block{user-select:none}
  </style>
</head>
<body>
<header>
  <div class="bar">
    <strong>批量裁剪 1:1 / 3:4 → 导出 JPEG（本地运行，无需上传至服务器）</strong>
    <span class="hint">拖入图片 → 选择比例与尺寸 → 逐张微调 → 保存到文件夹</span>
  </div>
</header>
<main>
  <section class="panel">
    <div class="controls">
      <label>选择/拖入图片
        <input id="fileInput" type="file" accept="image/*" multiple>
        <div class="muted" style="margin-top:6px; font-size:12px">或按 <strong>Ctrl/Cmd</strong>+<strong>V</strong> 粘贴图片</div>
      </label>
      <div class="row">
        <label>SPU（用于命名/子目录）
          <input id="spu" type="text" placeholder="如：spu123">
        </label>
        <label>起始序号
          <input id="startIndex" type="number" value="1" min="1">
        </label>
      </div>
      <div class="row">
        <label>目标比例
          <select id="ratio">
            <option value="0.75">3:4（竖版，默认）</option>
            <option value="1">1:1（方形）</option>
          </select>
        </label>
        <label>输出尺寸（宽×高）
          <!-- 设为只读：不可编辑，只随比例变化 -->
          <input id="size" type="text" value="1500x2000" readonly>
        </label>
      </div>
      <div class="row">
        <label>JPEG 质量（0.5~1）
          <input id="quality" type="number" value="0.9" min="0.5" max="1" step="0.05">
        </label>
        <label>文件名后缀
          <input id="suffix" type="text" value="_auto" placeholder="如 _1500x2000 或 _auto">
        </label>
      </div>

      <div class="toolbar">
        <button id="pickFolder" class="btn secondary">选择 Base 文件夹</button>
        <button id="exportAll" class="btn">Save all（Ctrl+Enter）</button>
        <button id="exportOne" class="btn secondary">保存当前</button>
        <button id="clear" class="btn secondary">清空</button>
        <!-- Debug helper: enlarge crop box beyond image to test padding -->
        <button id="debugEnlarge" class="btn secondary">测试：扩大裁剪框</button>
      </div>
      <div class="muted">已选文件夹：<span id="folderPath">未选择</span></div>
      <hr>
      <div class="thumbs drop-block" id="thumbs" title="此区域禁止拖入（避免重复添加）"></div>
    </div>
  </section>
  <section class="panel">
    <div id="canvasWrap" class="drop-target" title="可直接把图片从其它标签页拖到此区域" tabindex="0" role="button" aria-label="可点击并按 Ctrl/Cmd+V 粘贴图片">
      <img id="previewImg" alt="预览将显示在这里">
    </div>
    <div class="muted" style="margin-top:8px">右键预览可删除当前；右键缩略图可删除；缩略图右上角“×”可删除。</div>
  </section>
</main>
<footer>
  <div>⚙️ 操作提示：选择比例后，拖动/缩放裁剪框以对齐主体。保存成功后会在底部显示提示，并自动清空当前列表。</div>
</footer>

<div id="toast" class="toast">已保存</div>

<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
<script>
// ------- State -------
let files = [];           // { file, url, key, cropState? }
let activeIndex = -1;
let cropper = null;
let dirHandle = null;     // File System Access API directory handle
const addedKeys = new Set();

// ------- Shorthands -------
const el = (id)=>document.getElementById(id);
const fileInput = el('fileInput');
const thumbs = el('thumbs');
const previewImg = el('previewImg');
const ratioSel = el('ratio');
const sizeInput = el('size');
const spuInput = el('spu');
const startIndexInput = el('startIndex');
const qualityInput = el('quality');
const suffixInput = el('suffix');
const toast = el('toast');
const canvasWrap = el('canvasWrap');
const folderPath = el('folderPath');

// ------- Persist last settings -------
const LAST_RATIO_KEY = 'tmpicup:lastRatio';

function loadPrefs(){
  const lastRatio = localStorage.getItem(LAST_RATIO_KEY);
  if(lastRatio){
    ratioSel.value = lastRatio;
  }else{
    ratioSel.value = '0.75';
  }
  // 输出尺寸固定随比例变化，不允许编辑
  sizeInput.value = ratioSel.value === '1' ? '1200x1200' : '1500x2000';
}
function savePrefs(){
  localStorage.setItem(LAST_RATIO_KEY, ratioSel.value);
}
loadPrefs();

// ------- UI helpers -------
function showToast(msg='已保存'){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 1800);
}

function renderThumbs(){
  thumbs.innerHTML = '';
  files.forEach((f, i)=>{
    const d = document.createElement('div');
    d.className = 'thumb' + (i===activeIndex ? ' active':'');
    const im = document.createElement('img');
    im.src = f.url;
    const close = document.createElement('div');
    close.className='close';
    close.textContent='×';
    close.title='删除此图';
    close.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeAt(i); });
    d.appendChild(im);
    d.appendChild(close);
    d.addEventListener('click', ()=> setActive(i));
    d.addEventListener('contextmenu', (e)=>{ e.preventDefault(); removeAt(i); });
    // 禁止在缩略图区域投放，避免误拖重复添加
    d.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
    d.addEventListener('drop', (e)=>{ e.preventDefault(); });
    thumbs.appendChild(d);
  });
}

function keyOfFile(f){
  return [f.name, f.size, f.type, f.lastModified].join('|');
}

function addFiles(blobs, makeActiveLatest=false){
  const added = [];
  for(const f of blobs){
    const key = keyOfFile(f);
    if(addedKeys.has(key)) continue;
    if(!/^image\//.test(f.type)) continue;
    const url = URL.createObjectURL(f);
    files.push({file:f, url, key, cropState:null});
    addedKeys.add(key);
    added.push(files.length-1);
  }
  if(files.length>0 && activeIndex<0) activeIndex = 0;
  renderThumbs();
  if(makeActiveLatest && added.length){
    setActive(added[added.length-1]);
  }else if(files.length>0){
    setActive(activeIndex);
  }
}

function removeAt(i){
  const it = files[i];
  if(!it) return;
  URL.revokeObjectURL(it.url);
  addedKeys.delete(it.key);
  files.splice(i,1);
  if(activeIndex>=files.length) activeIndex = files.length-1;
  renderThumbs();
  if(files.length>0) setActive(Math.max(0, activeIndex));
  else {
    if (cropper) { cropper.destroy(); cropper = null; }
    previewImg.removeAttribute('src');
    activeIndex = -1;
  }
}

// 保存当前活动图片的裁剪状态
function saveCurrentCropState(){
  if (activeIndex<0 || !cropper) return;
  const item = files[activeIndex];
  try{
    item.cropState = {
      data: cropper.getData(true),
      cropBox: cropper.getCropBoxData(),
      canvas: cropper.getCanvasData()
    };
  }catch(e){ /* ignore */ }
}

// 设置活动图片，并在就绪后恢复裁剪状态（如有）
// 返回 Promise，等裁剪器 ready 且状态恢复完成再 resolve
function setActive(i){
  if (cropper) {
    // 离开前保存旧的裁剪状态
    saveCurrentCropState();
    cropper.destroy();
    cropper = null;
  }
  activeIndex = i;
  renderThumbs();
  const item = files[i];
  if(!item) return Promise.resolve();
  previewImg.src = item.url;
  return new Promise((resolve)=>{
    previewImg.onload = ()=>{
      cropper = new Cropper(previewImg, {
        aspectRatio: parseFloat(ratioSel.value),
        viewMode: 0,
        autoCropArea: 1,
        background: false,
        ready(){
          // ready 后恢复之前保存的裁剪状态
          if(item.cropState){
            try{
              if(item.cropState.canvas) cropper.setCanvasData(item.cropState.canvas);
              if(item.cropState.cropBox) cropper.setCropBoxData(item.cropState.cropBox);
              if(item.cropState.data)     cropper.setData(item.cropState.data);
            }catch(e){ /* ignore */ }
          }
          // 绑定事件：任何调整都实时保存
          bindCropperEvents();
          resolve();
        }
      });
    };
  });
}

function bindCropperEvents(){
  if(!cropper) return;
  const save = ()=> saveCurrentCropState();
  // 尝试移除已有绑定（若实现不支持 off 不会报错)
  try{
    cropper.off && cropper.off('cropend');
    cropper.off && cropper.off('zoom');
    cropper.off && cropper.off('move');
    cropper.off && cropper.off('crop');
  }catch(e){}
  // 绑定事件：每次裁剪/移动/缩放都保存状态
  try{
    cropper.on && cropper.on('cropend', save);
    cropper.on && cropper.on('zoom', save);
    cropper.on && cropper.on('move', save);
    cropper.on && cropper.on('crop', save);
  }catch(e){}
}

function parseSize(v){
  // 容错解析：把常见分隔符替换成小写 x，去掉空白与全角字符
  try{
    if(!v) v = '';
    v = String(v).trim();
    // 把部分全角符号先替换成半角方便处理
    v = v.replace(/[\uFF1A\uFF0C\u00A0]/g, ':');
    // 把冒号、逗号、乘号等统一为 x
    v = v.replace(/[:：,，×\u00D7]/g, 'x');
    v = v.replace(/\s+/g, '');
    v = v.replace(/X/g, 'x');
    const m = v.match(/^(\d+)\s*x\s*(\d+)$/);
    if (m) return {w: parseInt(m[1],10), h: parseInt(m[2],10)};
  }catch(e){
    console.warn('parseSize normalization error', e);
  }

  // 如果仍解析失败：使用基于比例的默认回退值（确保不会中断保存流程）
  const fallback = (ratioSel && ratioSel.value === '1') ? {w:1200, h:1200} : {w:1500, h:2000};
  console.warn('parseSize failed for input:', v, ' -> fallback to', fallback);
  // 把回退值写回输入框（避免后续再次失败）
  try{ sizeInput.value = `${fallback.w}x${fallback.h}`; }catch(e){}
  return fallback;
}

// ------- Export helpers -------
async function canvasToJpegBlob(cropper, size, quality){
  // Support crop boxes that extend beyond the image bounds by drawing
  // the source image onto a white canvas so the out-of-image areas become white.
  try{
    const data = cropper.getData(true); // crop box in image pixels
    if(!data || !data.width || !previewImg || !previewImg.naturalWidth){
      // Fallback to Cropper's built-in method if anything is missing
      const canvas = cropper.getCroppedCanvas({ width:size.w, height:size.h });
      return await new Promise(res=> canvas.toBlob(res, 'image/jpeg', quality));
    }

    // scale factors to map crop box -> output size
    const scaleX = size.w / data.width;
    const scaleY = size.h / data.height;

    const canvas = document.createElement('canvas');
    canvas.width = size.w;
    canvas.height = size.h;
    const ctx = canvas.getContext('2d');

    // fill white background for padded areas
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // draw the full source image scaled so that the crop rect aligns with the output
    const drawWidth = previewImg.naturalWidth * scaleX;
    const drawHeight = previewImg.naturalHeight * scaleY;
    const drawX = -data.x * scaleX;
    const drawY = -data.y * scaleY;

    ctx.drawImage(previewImg, drawX, drawY, drawWidth, drawHeight);

    return await new Promise(res=> canvas.toBlob(res, 'image/jpeg', quality));
  }catch(e){
    console.warn('Custom canvas export failed, fallback to getCroppedCanvas', e);
    const canvas = cropper.getCroppedCanvas({ width:size.w, height:size.h });
    return await new Promise(res=> canvas.toBlob(res, 'image/jpeg', quality));
  }
}

async function ensureSubdir(handle, subdir){
  try{
    return await handle.getDirectoryHandle(subdir, {create:true});
  }catch(e){ console.error(e); return null; }
}

async function saveBlobToFS(dir, filename, blob){
  const f = await dir.getFileHandle(filename, {create:true});
  const w = await f.createWritable();
  await w.write(blob);
  await w.close();
}

// ------- Actions -------
async function exportCurrent(toFS=true){
  if (activeIndex<0 || !cropper) { showToast('请先选择一张图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size) { showToast('输出尺寸格式不正确'); return; }
  const q = Math.max(0.5, Math.min(1, parseFloat(qualityInput.value)||0.9));
  const spu = (spuInput.value.trim() || 'spu').replace(/[^\w\-]/g,'');
  const baseIndex = parseInt(startIndexInput.value)||1;
  const idx = baseIndex + activeIndex;
  const suffix = suffixInput.value || '_auto';
  const name = `${spu}-${String(idx).padStart(2,'0')}${suffix}.jpg`;

  // 导出前确保保存最新裁剪状态
  saveCurrentCropState();

  const blob = await canvasToJpegBlob(cropper, size, q);

  // 优先写入文件夹（需 https/localhost）
  if(toFS && dirHandle?.kind === 'directory'){
    try{
      const sub = await ensureSubdir(dirHandle, spu);
      if(sub){
        await saveBlobToFS(sub, name, blob);
        return { ok:true, filename:name, path:`${spu}/${name}`, method:'fs' };
      }
    }catch(e){
      console.warn('FS save failed, fallback to download', e);
    }
  }
  // 回退：浏览器下载
  const a = document.createElement('a');
  a.download = name;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  return { ok:true, filename:name, method:'download' };
}

async function exportAll(){
  if (files.length===0){ showToast('请先选择图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size){ showToast('输出尺寸格式不正确'); return; }
  savePrefs();

  // 先保存当前活动图片的裁剪状态（核心！）
  saveCurrentCropState();

  const originalActive = activeIndex;

  for (let i=0;i<files.length;i++){
    if (i === activeIndex && cropper){
      // 当前这张：不要调用 setActive，直接按当前裁剪状态导出
      await exportCurrent(true);
    } else {
      // 其它图片：切换到该图，并恢复其最后一次裁剪状态，再导出
      await setActive(i);
      await exportCurrent(true);
    }
    // 小延时，避免阻塞 UI
    await new Promise(r=> setTimeout(r, 60));
  }

  showToast('全部保存完成 ✅');
  clearAll();
}

function clearAll(){
  if (cropper) { cropper.destroy(); cropper = null; }
  files.forEach(f=> URL.revokeObjectURL(f.url));
  files = []; activeIndex=-1; renderThumbs(); previewImg.removeAttribute('src');
  addedKeys.clear();
}

// ------- Events -------
fileInput.addEventListener('change', e=>{
  addFiles(Array.from(e.target.files));
});

ratioSel.addEventListener('change', ()=>{
  // 切换比例时自动设置输出尺寸（不可编辑）并保存偏好
  if (ratioSel.value==='0.75'){
    sizeInput.value = '1500x2000';
  }else{
    sizeInput.value = '1200x1200';
  }

  if (cropper){
    // 切换比例：先保存当前裁剪状态，再改变比例，再尝试恢复
    saveCurrentCropState();
    cropper.setAspectRatio(parseFloat(ratioSel.value));
    const st = files[activeIndex]?.cropState;
    if (st){
      try{
        cropper.setCanvasData(st.canvas);
        cropper.setData(st.data);
      }catch(e){/* ignore */ }
    }
  }

  savePrefs();
});

el('exportOne').addEventListener('click', ()=> exportCurrent(true).then(()=>showToast('已保存当前')));
el('exportAll').addEventListener('click', exportAll);
el('clear').addEventListener('click', clearAll);

// Debug helper: programmatically enlarge crop box (useful to test cropping beyond image)
el('debugEnlarge').addEventListener('click', ()=>{
  if (!cropper) { showToast('请先选择图片'); return; }
  try{
    // Use current crop data and attempt to expand it significantly
    const st = cropper.getData(true);
    const ratio = parseFloat(ratioSel.value) || (st.width && st.height ? st.width / st.height : 1);
    const newW = Math.max( Math.round(st.width * 3),  Math.round(sizeInput.value.split('x')[0]||1500) );
    const newH = Math.round(newW / ratio);
    const newX = Math.round(st.x - (newW - st.width)/2);
    const newY = Math.round(st.y - (newH - st.height)/2);
    // Try setData first (preferred), otherwise setCropBoxData
    try{
      cropper.setData({ x:newX, y:newY, width:newW, height:newH });
    }catch(e){
      try{ cropper.setCropBoxData({ left:newX, top:newY, width:newW, height:newH }); }catch(_){ throw _; }
    }
    showToast('已尝试扩大裁剪框（请查看是否超出）');
  }catch(err){ console.warn(err); showToast('操作失败'); }
});

// 预览右键删除当前
previewImg.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  if(activeIndex>=0) removeAt(activeIndex);
});

// 粘贴支持：从剪贴板读取图片并复用上传逻辑（优先使用同步 clipboardData，回退到 navigator.clipboard.read）
document.addEventListener('paste', async (e)=>{
  const clipboard = e.clipboardData || window.clipboardData;
  if (!clipboard) return;

  const filesFromClipboard = [];
  // 优先处理 clipboardData 的 items（同步）
  if(clipboard.items && clipboard.items.length){
    for(const it of clipboard.items){
      try{
        if(it.kind === 'file' && it.type && it.type.startsWith('image/')){
          const file = it.getAsFile ? it.getAsFile() : it.getAsBlob && it.getAsBlob();
          if(file) filesFromClipboard.push(file);
        }
      }catch(_){/* ignore malformed items */}
    }
  }

  // 回退：尝试 navigator.clipboard.read（需权限、HTTPS）
  if(filesFromClipboard.length === 0 && navigator.clipboard && navigator.clipboard.read){
    try{
      const clipboardItems = await navigator.clipboard.read();
      for(const clipIt of clipboardItems){
        for(const type of clipIt.types){
          if(type.startsWith('image/')){
            const blob = await clipIt.getType(type);
            const file = new File([blob], 'clipboard.' + (type.split('/')[1] || 'png'), {type: blob.type});
            filesFromClipboard.push(file);
          }
        }
      }
    }catch(err){ /* permissions or unsupported - ignore */ }
  }

  // 额外尝试：粘贴 URL（文本）指向图片
  if(filesFromClipboard.length === 0){
    try{
      const text = clipboard.getData && clipboard.getData('text/plain');
      if(text && /^https?:\/\//.test(text)){
        const res = await fetch(text, {mode:'cors'});
        const blob = await res.blob();
        if(/^image\//.test(blob.type)){
          const f = new File([blob], 'pasted-remote.jpg', {type: blob.type});
          filesFromClipboard.push(f);
        }
      }
    }catch(err){ /* ignore cross-origin or fetch errors */ }
  }

  if(filesFromClipboard.length){
    const dropInPreview = document.activeElement && (document.activeElement === canvasWrap || canvasWrap.contains(document.activeElement));
    addFiles(filesFromClipboard, dropInPreview);
    e.preventDefault();
    showToast('已添加粘贴图片');
    return;
  }
});

// 整页拖拽支持
document.addEventListener('dragover', e=>{ e.preventDefault(); });
document.addEventListener('drop', async e=>{
  e.preventDefault();
  const dt = e.dataTransfer;
  if (!dt) return;
  if (dt.files && dt.files.length){
    const imgs = Array.from(dt.files).filter(f=>/^image\//.test(f.type));
    const dropInPreview = e.composedPath().includes(canvasWrap);
    addFiles(imgs, dropInPreview);
    return;
  }
  const url = dt.getData('text/uri-list') || dt.getData('text/plain');
  if(url){
    try{
      const res = await fetch(url, {mode:'cors'});
      const blob = await res.blob();
      if(!/^image\//.test(blob.type)) throw new Error('Not image');
      const f = new File([blob], 'remote.jpg', {type: blob.type});
      const dropInPreview = e.composedPath().includes(canvasWrap);
      addFiles([f], dropInPreview);
    }catch(err){
      showToast('跨域受限，无法直接获取；请先另存图片到本地后再拖入。');
    }
  }
});

// 缩略图容器整体禁投放
thumbs.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
thumbs.addEventListener('drop', (e)=>{ e.preventDefault(); });

// 键盘：Ctrl+Enter = Save all
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    exportAll();
  }
});

// 选择 Base 文件夹（File System Access API）
// 这里保留按钮但不做 IndexedDB 持久化，专注本次 bug 修复；需要可再加回
el('pickFolder').addEventListener('click', async ()=>{
  if (!('showDirectoryPicker' in window)){
    showToast('当前环境不支持文件夹写入（需 https 或 localhost）');
    return;
  }
  try{
    dirHandle = await window.showDirectoryPicker({id:'tmpicup-base'});
    folderPath.textContent = '已选择';
    showToast('已选择 Base 文件夹');
  }catch(e){
    if(e.name!=='AbortError') showToast('选择文件夹失败');
  }
});

// 保存用户偏好：只保存比例
ratioSel.addEventListener('change', savePrefs);
</script>
</body>
</html>
