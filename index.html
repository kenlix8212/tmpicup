<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>本地批量裁剪 1:1 / 3:4 → 导出JPEG（适配 Temu）</title>
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet">
  <style>
    :root{--accent:#111827;--accent-2:#374151;--border:#e5e7eb;--bg:#f3f4f6;}
    *{box-sizing:border-box}
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #111827; color: #fff; }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 16px; padding: 16px; }
    .panel { border: 1px solid var(--border); border-radius: 8px; padding: 12px; background:#fff; }
    .thumbs { display: grid; grid-template-columns: repeat(auto-fill, minmax(88px,1fr)); gap: 8px; max-height: 60vh; overflow: auto; }
    .thumb { position:relative; border: 2px solid transparent; border-radius: 6px; padding: 2px; cursor: pointer; background:#f9fafb; }
    .thumb.active { border-color: #3b82f6; background:#eff6ff; }
    .thumb img { width: 100%; display: block; border-radius: 4px; }
    .thumb .close {position:absolute; right:4px; top:4px; width:20px; height:20px; line-height:18px; text-align:center; border-radius:10px; background:#111827; color:#fff; font-weight:700; font-size:12px; display:none; cursor:pointer;}
    .thumb:hover .close{display:block;}
    .controls label { display:block; font-size: 13px; margin-top: 8px; }
    .controls input[type="text"], .controls input[type="number"], .controls select { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #d1d5db; }
    .controls .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .btn { display:inline-flex; align-items:center; gap:6px; background:var(--accent); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:var(--accent-2); }
    .btn[disabled] { opacity:.5; cursor:not-allowed; }
    #canvasWrap { display:flex; align-items:center; justify-content:center; height: 70vh; background:var(--bg); border-radius:8px; overflow:hidden; border:1px dashed var(--border); }
    #previewImg { max-width:100%; max-height:100%; }
    footer { padding: 12px 16px; color:#6b7280; font-size:12px; }
    .bar { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .hint { font-size: 12px; color:#cbd5e1; }
    .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:14px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; font-size:13px; opacity:0; transition:opacity .2s, transform .2s;}
    .toast.show{opacity:1; transform:translate(-50%,-6px)}
    .muted{color:#6b7280; font-size:12px}
    .drop-block{user-select:none}
  </style>
</head>
<body>
<header>
  <div class="bar">
    <strong>批量裁剪 1:1 / 3:4 → 导出 JPEG（本地运行，无需上传至服务器）</strong>
    <span class="hint">拖入图片 → 选择比例与尺寸 → 逐张微调 → 保存到文件夹</span>
  </div>
</header>
<main>
  <section class="panel">
    <div class="controls">
      <label>选择/拖入图片
        <input id="fileInput" type="file" accept="image/*" multiple>
      </label>
      <div class="row">
        <label>SPU（用于命名/子目录）
          <input id="spu" type="text" placeholder="如：spu123">
        </label>
        <label>起始序号
          <input id="startIndex" type="number" value="1" min="1">
        </label>
      </div>
      <div class="row">
        <label>目标比例
          <select id="ratio">
            <option value="0.75">3:4（竖版，默认）</option>
            <option value="1">1:1（方形）</option>
          </select>
        </label>
        <label>输出尺寸（宽×高）
          <!-- 设为只读：不可编辑，只随比例变化 -->
          <input id="size" type="text" value="1500x2000" readonly>
        </label>
      </div>
      <div class="row">
        <label>JPEG 质量（0.5~1）
            <div style="display:flex; gap:6px; align-items:center">
              <input id="quality" type="number" value="0.9" min="0.5" max="1" step="0.05" style="flex:1">
              <button id="advToggle" title="高级设置" class="btn" style="padding:6px 8px; font-size:12px">⚙</button>
            </div>
        </label>
        <label>文件名后缀
          <input id="suffix" type="text" value="_auto" placeholder="如 _1500x2000 或 _auto">
        </label>
      </div>

      <!-- Advanced settings (collapsed by default) -->
      <div id="advancedPanel" style="display:none; margin-top:8px; padding:8px; border-radius:6px; background:#f8fafc; border:1px solid #e6eef6">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px">
          <label>最大文件大小（MB）
            <input id="maxSizeMb" type="number" min="0.1" step="0.1" value="1.9">
          </label>
          <label style="align-self:end"><input id="autoAdjustQuality" type="checkbox" checked> 自动调整质量</label>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center">
          <label style="display:flex; gap:8px; align-items:center"><input id="allowDownscale" type="checkbox"> 允许按比例缩小分辨率（默认关闭）</label>
          <button id="resetDefaults" class="btn secondary" style="margin-left:auto">恢复默认</button>
        </div>
      </div>

      <div class="toolbar">
        <button id="pickFolder" class="btn secondary">选择 Base 文件夹</button>
        <button id="exportAll" class="btn">Save all（Ctrl+Enter）</button>
        <button id="exportOne" class="btn secondary">保存当前</button>
        <button id="clear" class="btn secondary">清空</button>
      </div>
      <div class="muted">已选文件夹：<span id="folderPath">未选择</span></div>
      <hr>
      <div class="thumbs drop-block" id="thumbs" title="此区域禁止拖入（避免重复添加）"></div>
    </div>
  </section>
  <section class="panel">
    <div id="canvasWrap" class="drop-target" title="可直接把图片从其它标签页拖到此区域">
      <img id="previewImg" alt="预览将显示在这里">
    </div>
    <div class="muted" style="margin-top:8px">右键预览可删除当前；右键缩略图可删除；缩略图右上角“×”可删除。</div>
  </section>
</main>
<footer>
  <div>⚙️ 操作提示：选择比例后，拖动/缩放裁剪框以对齐主体。保存成功后会在底部显示提示，并自动清空当前列表。</div>
</footer>

<div id="toast" class="toast">已保存</div>

<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
<script>
// ------- State -------
let files = [];           // { file, url, key, cropState? }
let activeIndex = -1;
let cropper = null;
let dirHandle = null;     // File System Access API directory handle
const addedKeys = new Set();

// ------- Shorthands -------
const el = (id)=>document.getElementById(id);
const fileInput = el('fileInput');
const thumbs = el('thumbs');
const previewImg = el('previewImg');
const ratioSel = el('ratio');
const sizeInput = el('size');
const spuInput = el('spu');
const startIndexInput = el('startIndex');
const qualityInput = el('quality');
const suffixInput = el('suffix');
const toast = el('toast');
const canvasWrap = el('canvasWrap');
const folderPath = el('folderPath');
const advToggle = () => el('advToggle');
const advancedPanel = () => el('advancedPanel');
const maxSizeMbInput = () => el('maxSizeMb');
const autoAdjustQualityInput = () => el('autoAdjustQuality');
const allowDownscaleInput = () => el('allowDownscale');
const resetDefaultsBtn = () => el('resetDefaults');

// ------- Persist last settings -------
const LAST_RATIO_KEY = 'tmpicup:lastRatio';

function loadPrefs(){
  const lastRatio = localStorage.getItem(LAST_RATIO_KEY);
  if(lastRatio){
    ratioSel.value = lastRatio;
  }else{
    ratioSel.value = '0.75';
  }
  // 输出尺寸固定随比例变化，不允许编辑
  sizeInput.value = ratioSel.value === '1' ? '1200x1200' : '1500x2000';
}
function savePrefs(){
  localStorage.setItem(LAST_RATIO_KEY, ratioSel.value);
}
loadPrefs();

// ------- Advanced settings persistence & defaults -------
const ADV_KEY = 'tmpicup:advanced';
const ADV_DEFAULTS = { maxSizeMb: 1.9, autoAdjustQuality: true, allowDownscale: false, modified: false };
function loadAdvanced(){
  try{
    const raw = localStorage.getItem(ADV_KEY);
    if(!raw) return {...ADV_DEFAULTS};
    const v = JSON.parse(raw);
    return Object.assign({}, ADV_DEFAULTS, v);
  }catch(e){ return {...ADV_DEFAULTS}; }
}
function saveAdvanced(opts){
  localStorage.setItem(ADV_KEY, JSON.stringify(opts));
}
function resetAdvanced(){ saveAdvanced({...ADV_DEFAULTS}); renderAdvanced(); }
function renderAdvanced(){
  const a = loadAdvanced();
  try{ maxSizeMbInput().value = a.maxSizeMb; }catch(e){}
  try{ autoAdjustQualityInput().checked = !!a.autoAdjustQuality; }catch(e){}
  try{ allowDownscaleInput().checked = !!a.allowDownscale; }catch(e){}
}
renderAdvanced();

// Toggle panel
el('advToggle').addEventListener('click', ()=>{
  const p = el('advancedPanel');
  if(p.style.display === 'none') p.style.display = 'block'; else p.style.display = 'none';
});
resetDefaultsBtn().addEventListener('click', ()=>{ resetAdvanced(); showToast('已恢复默认'); });
maxSizeMbInput().addEventListener('change', ()=>{ const a = loadAdvanced(); a.maxSizeMb = parseFloat(maxSizeMbInput().value)||1.9; a.modified = true; saveAdvanced(a); });
autoAdjustQualityInput().addEventListener('change', ()=>{ const a = loadAdvanced(); a.autoAdjustQuality = !!autoAdjustQualityInput().checked; a.modified = true; saveAdvanced(a); });
allowDownscaleInput().addEventListener('change', ()=>{ const a = loadAdvanced(); a.allowDownscale = !!allowDownscaleInput().checked; a.modified = true; saveAdvanced(a); });

// Helper: generate blob with quality limit (binary search), respecting cannot-downscale rule
async function generateBlobWithLimit(cropperInstance, size, startQuality, opts){
  // opts: { maxBytes, minQuality=0.5, maxAttempts=6, allowDownscale }
  const maxBytes = opts.maxBytes || 1900000;
  const minQuality = typeof opts.minQuality === 'number' ? opts.minQuality : 0.5;
  const maxAttempts = opts.maxAttempts || 6;

  // first try at startQuality
  let qHigh = Math.min(1, startQuality);
  let qLow = minQuality;

  const blobAt = async (q, s) => {
    // when resizing required, we need to draw cropped canvas at new size
    if(s && (s.w !== size.w || s.h !== size.h)){
      // get cropped canvas at original size and then scale into new canvas
      const tmp = cropperInstance.getCroppedCanvas({ width: size.w, height: size.h });
      const out = document.createElement('canvas'); out.width = s.w; out.height = s.h;
      const ctx = out.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,s.w,s.h);
      ctx.drawImage(tmp, 0, 0, s.w, s.h);
      return await new Promise(r=> out.toBlob(r, 'image/jpeg', q));
    }
    // normal path
    const out = cropperInstance.getCroppedCanvas({ width: size.w, height: size.h });
    const final = document.createElement('canvas'); final.width = size.w; final.height = size.h;
    const ctx = final.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,final.width, final.height);
    ctx.drawImage(out,0,0);
    return await new Promise(r=> final.toBlob(r, 'image/jpeg', q));
  };

  // quick initial try
  let blob = await blobAt(qHigh);
  if(blob && blob.size <= maxBytes) return { blob, usedQuality: qHigh, usedSize: {w: size.w, h: size.h}, ok:true };

  // if auto quality disabled, return initial blob
  if(!opts.autoQuality) return { blob, usedQuality: qHigh, usedSize: {w:size.w,h:size.h}, ok: blob.size<=maxBytes };

  // binary search quality
  let lastGood = null;
  for(let i=0;i<maxAttempts;i++){
    const mid = Math.max(minQuality, (qLow + qHigh)/2);
    const b = await blobAt(mid);
    if(b && b.size <= maxBytes){ lastGood = {blob:b, usedQuality: mid}; qLow = mid; }
    else { qHigh = mid; }
    // stop when qHigh - qLow small
    if((qHigh - qLow) < 0.02) break;
  }
  if(lastGood) return { blob:lastGood.blob, usedQuality:lastGood.usedQuality, usedSize:{w:size.w,h:size.h}, ok:true };

  // if allowDownscale is true and caller allows, attempt a single downscale step (but caller requested 'cannot shrink' so we won't shrink by default)
  if(opts.allowDownscale){
    // compute rough scale needed
    const estimatedScale = Math.sqrt(maxBytes / (blob ? blob.size : (maxBytes*4)));
    const scale = Math.max(0.6, Math.min(1, estimatedScale));
    const newSize = { w: Math.round(size.w * scale), h: Math.round(size.h * scale) };
    // ensure not below UI size if caller forbids shrinking; caller controls allowDownscale
    const b2 = await blobAt(Math.max(minQuality, qLow), newSize);
    if(b2 && b2.size <= maxBytes) return { blob:b2, usedQuality: Math.max(minQuality,qLow), usedSize:newSize, ok:true };
    // return best we have
    return { blob: b2 || blob, usedQuality: Math.max(minQuality,qLow), usedSize:newSize, ok: (b2? b2.size<=maxBytes:false) };
  }

  // fallback: return last generated blob (likely larger than max)
  return { blob, usedQuality: qLow, usedSize: {w:size.w,h:size.h}, ok:false };
}

// ------- UI helpers -------
function showToast(msg='已保存'){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 1800);
}

function renderThumbs(){
  thumbs.innerHTML = '';
  files.forEach((f, i)=>{
    const d = document.createElement('div');
    d.className = 'thumb' + (i===activeIndex ? ' active':'');
    const im = document.createElement('img');
    im.src = f.url;
    const close = document.createElement('div');
    close.className='close';
    close.textContent='×';
    close.title='删除此图';
    close.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeAt(i); });
    d.appendChild(im);
    d.appendChild(close);
    d.addEventListener('click', ()=> setActive(i));
    d.addEventListener('contextmenu', (e)=>{ e.preventDefault(); removeAt(i); });
    // 禁止在缩略图区域投放，避免误拖重复添加
    d.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
    d.addEventListener('drop', (e)=>{ e.preventDefault(); });
    thumbs.appendChild(d);
  });
}

function keyOfFile(f){
  return [f.name, f.size, f.type, f.lastModified].join('|');
}

function addFiles(blobs, makeActiveLatest=false){
  const added = [];
  for(const f of blobs){
    const key = keyOfFile(f);
    if(addedKeys.has(key)) continue;
    if(!/^image\//.test(f.type)) continue;
    const url = URL.createObjectURL(f);
    files.push({file:f, url, key, cropState:null});
    addedKeys.add(key);
    added.push(files.length-1);
  }
  if(files.length>0 && activeIndex<0) activeIndex = 0;
  renderThumbs();
  if(makeActiveLatest && added.length){
    setActive(added[added.length-1]);
  }else if(files.length>0){
    setActive(activeIndex);
  }
}

function removeAt(i){
  const it = files[i];
  if(!it) return;
  URL.revokeObjectURL(it.url);
  addedKeys.delete(it.key);
  files.splice(i,1);
  if(activeIndex>=files.length) activeIndex = files.length-1;
  renderThumbs();
  if(files.length>0) setActive(Math.max(0, activeIndex));
  else {
    if (cropper) { cropper.destroy(); cropper = null; }
    previewImg.removeAttribute('src');
    activeIndex = -1;
  }
}

// 保存当前活动图片的裁剪状态
function saveCurrentCropState(){
  if (activeIndex<0 || !cropper) return;
  const item = files[activeIndex];
  try{
    item.cropState = {
      data: cropper.getData(true),
      cropBox: cropper.getCropBoxData(),
      canvas: cropper.getCanvasData()
    };
  }catch(e){ /* ignore */ }
}

// 设置活动图片，并在就绪后恢复裁剪状态（如有）
// 返回 Promise，等裁剪器 ready 且状态恢复完成再 resolve
function setActive(i){
  if (cropper) {
    // 离开前保存旧的裁剪状态
    saveCurrentCropState();
    cropper.destroy();
    cropper = null;
  }
  activeIndex = i;
  renderThumbs();
  const item = files[i];
  if(!item) return Promise.resolve();
  previewImg.src = item.url;
  return new Promise((resolve)=>{
    previewImg.onload = ()=>{
      cropper = new Cropper(previewImg, {
        aspectRatio: parseFloat(ratioSel.value),
  viewMode: 0,
        autoCropArea: 1,
        background: false,
        ready(){
          // ready 后恢复之前保存的裁剪状态
          if(item.cropState){
            try{
              if(item.cropState.canvas) cropper.setCanvasData(item.cropState.canvas);
              if(item.cropState.cropBox) cropper.setCropBoxData(item.cropState.cropBox);
              if(item.cropState.data)     cropper.setData(item.cropState.data);
            }catch(e){ /* ignore */ }
          }
          // 绑定事件：任何调整都实时保存
          bindCropperEvents();
          resolve();
        }
      });
    };
  });
}

function bindCropperEvents(){
  if(!cropper) return;
  const save = ()=> saveCurrentCropState();
  // 尝试移除已有绑定（若实现不支持 off 不会报错)
  try{
    cropper.off && cropper.off('cropend');
    cropper.off && cropper.off('zoom');
    cropper.off && cropper.off('move');
    cropper.off && cropper.off('crop');
  }catch(e){}
  // 绑定事件：每次裁剪/移动/缩放都保存状态
  try{
    cropper.on && cropper.on('cropend', save);
    cropper.on && cropper.on('zoom', save);
    cropper.on && cropper.on('move', save);
    cropper.on && cropper.on('crop', save);
  }catch(e){}
}

function parseSize(v){
  // 容错解析：把常见分隔符替换成小写 x，去掉空白与全角字符
  try{
    if(!v) v = '';
    v = String(v).trim();
    // 把部分全角符号先替换成半角方便处理
    v = v.replace(/[\uFF1A\uFF0C\u00A0]/g, ':');
    // 把冒号、逗号、乘号等统一为 x
    v = v.replace(/[:：,，×\u00D7]/g, 'x');
    v = v.replace(/\s+/g, '');
    v = v.replace(/X/g, 'x');
    const m = v.match(/^(\d+)\s*x\s*(\d+)$/);
    if (m) return {w: parseInt(m[1],10), h: parseInt(m[2],10)};
  }catch(e){
    console.warn('parseSize normalization error', e);
  }

  // 如果仍解析失败：使用基于比例的默认回退值（确保不会中断保存流程）
  const fallback = (ratioSel && ratioSel.value === '1') ? {w:1200, h:1200} : {w:1500, h:2000};
  console.warn('parseSize failed for input:', v, ' -> fallback to', fallback);
  // 把回退值写回输入框（避免后续再次失败）
  try{ sizeInput.value = `${fallback.w}x${fallback.h}`; }catch(e){}
  return fallback;
}

// ------- Export helpers -------
async function canvasToJpegBlob(cropper, size, quality){
  // Get the cropped canvas from cropper. When the crop box extends beyond the
  // source image this canvas may contain transparent areas. To ensure exported
  // JPEG has a white background (not transparent), draw the cropped result
  // onto a new same-size canvas with white fill first.
  const cropped = cropper.getCroppedCanvas({ width: size.w, height: size.h });
  const out = document.createElement('canvas');
  out.width = size.w;
  out.height = size.h;
  const ctx = out.getContext('2d');
  // Fill white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, out.width, out.height);
  // Draw the cropped image (may include transparent areas) onto the white canvas
  ctx.drawImage(cropped, 0, 0);
  return await new Promise(res => out.toBlob(res, 'image/jpeg', quality));
}

async function ensureSubdir(handle, subdir){
  try{
    return await handle.getDirectoryHandle(subdir, {create:true});
  }catch(e){ console.error(e); return null; }
}

async function saveBlobToFS(dir, filename, blob){
  const f = await dir.getFileHandle(filename, {create:true});
  const w = await f.createWritable();
  await w.write(blob);
  await w.close();
}

// ------- Actions -------
async function exportCurrent(toFS=true){
  if (activeIndex<0 || !cropper) { showToast('请先选择一张图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size) { showToast('输出尺寸格式不正确'); return; }
  const q = Math.max(0.5, Math.min(1, parseFloat(qualityInput.value)||0.9));
  const spu = (spuInput.value.trim() || 'spu').replace(/[^\w\-]/g,'');
  const baseIndex = parseInt(startIndexInput.value)||1;
  const idx = baseIndex + activeIndex;
  const suffix = suffixInput.value || '_auto';
  const name = `${spu}-${String(idx).padStart(2,'0')}${suffix}.jpg`;

  // 导出前确保保存最新裁剪状态
  saveCurrentCropState();

  // load advanced settings
  const adv = loadAdvanced();
  const maxBytes = Math.max(1024, Math.floor((parseFloat(adv.maxSizeMb)||1.9) * 1024 * 1024));
  // enforce cannot shrink: do not allow downscale unless adv.allowDownscale true
  const genRes = await generateBlobWithLimit(cropper, size, q, { maxBytes, autoQuality: !!adv.autoAdjustQuality, allowDownscale: !!adv.allowDownscale });
  const blob = genRes.blob;

  // If not ok and this is single export, notify user to use smaller source
  if(!genRes.ok){
    if(toFS){
      // single export path: inform user
      showToast('已达到最低质量，文件仍超限，请尝试更小的图片。');
    }
    // For batch exports, caller will handle skipping logic (we return blob anyway)
  }

  // 优先写入文件夹（需 https/localhost）
  if(toFS && dirHandle?.kind === 'directory'){
    try{
      const sub = await ensureSubdir(dirHandle, spu);
      if(sub){
        await saveBlobToFS(sub, name, blob);
        return { ok: genRes.ok===undefined ? true : genRes.ok, filename:name, path:`${spu}/${name}`, method:'fs' };
      }
    }catch(e){
      console.warn('FS save failed, fallback to download', e);
    }
  }
  // 回退：浏览器下载
  const a = document.createElement('a');
  a.download = name;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  return { ok: genRes.ok===undefined ? true : genRes.ok, filename:name, method:'download' };
}

async function exportAll(){
  if (files.length===0){ showToast('请先选择图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size){ showToast('输出尺寸格式不正确'); return; }
  savePrefs();

  // 先保存当前活动图片的裁剪状态（核心！）
  saveCurrentCropState();

  const originalActive = activeIndex;

  for (let i=0;i<files.length;i++){
    if (i === activeIndex && cropper){
      // 当前这张：不要调用 setActive，直接按当前裁剪状态导出
      const res = await exportCurrent(true);
      if(res && res.ok===false) skipped.push(i);
    } else {
      // 其它图片：切换到该图，并恢复其最后一次裁剪状态，再导出
      await setActive(i);
      const res = await exportCurrent(true);
      if(res && res.ok===false) skipped.push(i);
    }
    // 小延时，避免阻塞 UI
    await new Promise(r=> setTimeout(r, 60));
  }

  if(skipped.length){
    showToast(`部分图片超出限制被跳过：${skipped.length} 张`);
  } else {
    showToast('全部保存完成 ✅');
  }
  clearAll();
}

function clearAll(){
  if (cropper) { cropper.destroy(); cropper = null; }
  files.forEach(f=> URL.revokeObjectURL(f.url));
  files = []; activeIndex=-1; renderThumbs(); previewImg.removeAttribute('src');
  addedKeys.clear();
}

// ------- Events -------
fileInput.addEventListener('change', e=>{
  addFiles(Array.from(e.target.files));
});

ratioSel.addEventListener('change', ()=>{
  // 切换比例时自动设置输出尺寸（不可编辑）并保存偏好
  if (ratioSel.value==='0.75'){
    sizeInput.value = '1500x2000';
  }else{
    sizeInput.value = '1200x1200';
  }

  if (cropper){
    // 切换比例：先保存当前裁剪状态，再改变比例，再尝试恢复
    saveCurrentCropState();
    cropper.setAspectRatio(parseFloat(ratioSel.value));
    const st = files[activeIndex]?.cropState;
    if (st){
      try{
        cropper.setCanvasData(st.canvas);
        cropper.setData(st.data);
      }catch(e){/* ignore */ }
    }
  }

  savePrefs();
});

el('exportOne').addEventListener('click', ()=> exportCurrent(true).then(()=>showToast('已保存当前')));
el('exportAll').addEventListener('click', exportAll);
el('clear').addEventListener('click', clearAll);

// 预览右键删除当前
previewImg.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  if(activeIndex>=0) removeAt(activeIndex);
});

// 整页拖拽支持
document.addEventListener('dragover', e=>{ e.preventDefault(); });
document.addEventListener('drop', async e=>{
  e.preventDefault();
  const dt = e.dataTransfer;
  if (!dt) return;
  if (dt.files && dt.files.length){
    const imgs = Array.from(dt.files).filter(f=>/^image\//.test(f.type));
    const dropInPreview = e.composedPath().includes(canvasWrap);
    addFiles(imgs, dropInPreview);
    return;
  }
  const url = dt.getData('text/uri-list') || dt.getData('text/plain');
  if(url){
    try{
      const res = await fetch(url, {mode:'cors'});
      const blob = await res.blob();
      if(!/^image\//.test(blob.type)) throw new Error('Not image');
      const f = new File([blob], 'remote.jpg', {type: blob.type});
      const dropInPreview = e.composedPath().includes(canvasWrap);
      addFiles([f], dropInPreview);
    }catch(err){
      showToast('跨域受限，无法直接获取；请先另存图片到本地后再拖入。');
    }
  }
});

// 缩略图容器整体禁投放
thumbs.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
thumbs.addEventListener('drop', (e)=>{ e.preventDefault(); });

// 键盘：Ctrl+Enter = Save all
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    exportAll();
  }
});

// 选择 Base 文件夹（File System Access API）
// 这里保留按钮但不做 IndexedDB 持久化，专注本次 bug 修复；需要可再加回
el('pickFolder').addEventListener('click', async ()=>{
  if (!('showDirectoryPicker' in window)){
    showToast('当前环境不支持文件夹写入（需 https 或 localhost）');
    return;
  }
  try{
    dirHandle = await window.showDirectoryPicker({id:'tmpicup-base'});
    folderPath.textContent = '已选择';
    showToast('已选择 Base 文件夹');
  }catch(e){
    if(e.name!=='AbortError') showToast('选择文件夹失败');
  }
});

// 保存用户偏好：只保存比例
ratioSel.addEventListener('change', savePrefs);
</script>
</body>
</html>
