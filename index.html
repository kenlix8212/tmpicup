<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>本地批量裁剪 1:1 / 3:4 → 导出JPEG（适配 Temu）</title>
  <link href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet">
  <style>
    :root{--accent:#111827;--accent-2:#374151;--border:#e5e7eb;--bg:#f3f4f6;}
    *{box-sizing:border-box}
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #111827; color: #fff; }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 16px; padding: 16px; }
    .panel { border: 1px solid var(--border); border-radius: 8px; padding: 12px; background:#fff; }
    .thumbs { display: grid; grid-template-columns: repeat(auto-fill, minmax(88px,1fr)); gap: 8px; max-height: 60vh; overflow: auto; }
    .thumb { position:relative; border: 2px solid transparent; border-radius: 6px; padding: 2px; cursor: pointer; background:#f9fafb; }
    .thumb.active { border-color: #3b82f6; background:#eff6ff; }
    .thumb img { width: 100%; display: block; border-radius: 4px; }
    .thumb .close {position:absolute; right:4px; top:4px; width:20px; height:20px; line-height:18px; text-align:center; border-radius:10px; background:#111827; color:#fff; font-weight:700; font-size:12px; opacity:.8; display:none;}
    .thumb:hover .close{display:block;}
    .controls label { display:block; font-size: 13px; margin-top: 8px; }
    .controls input[type="text"], .controls input[type="number"], .controls select { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #d1d5db; }
    .controls .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .btn { display:inline-flex; align-items:center; gap:6px; background:var(--accent); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:var(--accent-2); }
    .btn[disabled] { opacity:.5; cursor:not-allowed; }
    #canvasWrap { display:flex; align-items:center; justify-content:center; height: 70vh; background:var(--bg); border-radius:8px; overflow:hidden; border:1px dashed var(--border); }
    #previewImg { max-width:100%; max-height:100%; }
    footer { padding: 12px 16px; color:#6b7280; font-size:12px; }
    .bar { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .hint { font-size: 12px; color:#cbd5e1; }
    .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:14px; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; font-size:13px; opacity:0; transition:opacity .2s, transform .2s; pointer-events:none}
    .toast.show{opacity:1; transform:translate(-50%,-6px)}
    .muted{color:#6b7280; font-size:12px}
    .drop-block{user-select:none}
  </style>
</head>
<body>
<header>
  <div class="bar">
    <strong>批量裁剪 1:1 / 3:4 → 导出 JPEG（本地运行，无需上传至服务器）</strong>
    <span class="hint">拖入图片 → 选择比例与尺寸 → 逐张微调 → 保存到文件夹</span>
  </div>
</header>
<main>
  <section class="panel">
    <div class="controls">
      <label>选择/拖入图片
        <input id="fileInput" type="file" accept="image/*" multiple>
      </label>
      <div class="row">
        <label>SPU（用于命名/子目录）
          <input id="spu" type="text" placeholder="如：spu123">
        </label>
        <label>起始序号
          <input id="startIndex" type="number" value="1" min="1">
        </label>
      </div>
      <div class="row">
        <label>目标比例
          <select id="ratio">
            <option value="0.75">3:4（竖版，默认）</option>
            <option value="1">1:1（方形）</option>
          </select>
        </label>
        <label>输出尺寸（宽×高）
          <input id="size" type="text" value="1500x2000" placeholder="如 1500x2000 或 1200x1200">
        </label>
      </div>
      <div class="row">
        <label>JPEG 质量（0.5~1）
          <input id="quality" type="number" value="0.9" min="0.5" max="1" step="0.05">
        </label>
        <label>文件名后缀
          <input id="suffix" type="text" value="_auto" placeholder="如 _1500x2000 或 _auto">
        </label>
      </div>

      <div class="toolbar">
        <button id="pickFolder" class="btn secondary">选择 Base 文件夹</button>
        <button id="exportAll" class="btn">Save all（Ctrl+Enter）</button>
        <button id="exportOne" class="btn secondary">保存当前</button>
        <button id="clear" class="btn secondary">清空</button>
      </div>
      <div class="muted">已选文件夹：<span id="folderPath">未选择</span></div>
      <hr>
      <div class="thumbs drop-block" id="thumbs" title="此区域禁止拖入（避免重复添加）"></div>
    </div>
  </section>
  <section class="panel">
    <div id="canvasWrap" class="drop-target" title="可直接把图片从其它标签页拖到此区域">
      <img id="previewImg" alt="预览将显示在这里">
    </div>
    <div class="muted" style="margin-top:8px">右键预览可删除当前；右键缩略图可删除；缩略图右上角“×”可删除。</div>
  </section>
</main>
<footer>
  <div>⚙️ 操作提示：选择比例后，拖动/缩放裁剪框以对齐主体。保存成功后会在底部显示提示，并自动清空当前列表。</div>
</footer>

<div id="toast" class="toast">已保存</div>

<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
<script>
// ------- State -------
let files = [];           // { file, url, key, cropState? }
let activeIndex = -1;
let cropper = null;
let dirHandle = null;     // File System Access API directory handle
const addedKeys = new Set();

// ------- Shorthands -------
const el = (id)=>document.getElementById(id);
const fileInput = el('fileInput');
const thumbs = el('thumbs');
const previewImg = el('previewImg');
const ratioSel = el('ratio');
const sizeInput = el('size');
const spuInput = el('spu');
const startIndexInput = el('startIndex');
const qualityInput = el('quality');
const suffixInput = el('suffix');
const toast = el('toast');
const canvasWrap = el('canvasWrap');
const folderPath = el('folderPath');

// ------- Persist last settings -------
const LAST_RATIO_KEY = 'tmpicup:lastRatio';
const LAST_SIZE_1 = 'tmpicup:size:1';
const LAST_SIZE_075 = 'tmpicup:size:0.75';

function loadPrefs(){
  const lastRatio = localStorage.getItem(LAST_RATIO_KEY);
  if(lastRatio){
    ratioSel.value = lastRatio;
    const size = localStorage.getItem(lastRatio==='1'?LAST_SIZE_1:LAST_SIZE_075);
    if(size) sizeInput.value = size;
  }else{
    ratioSel.value = '0.75';
    sizeInput.value = '1500x2000';
  }
}
function savePrefs(){
  localStorage.setItem(LAST_RATIO_KEY, ratioSel.value);
  const key = ratioSel.value==='1'?LAST_SIZE_1:LAST_SIZE_075;
  localStorage.setItem(key, sizeInput.value.trim());
}
loadPrefs();

// ------- UI helpers -------
function showToast(msg='已保存'){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 1800);
}

function renderThumbs(){
  thumbs.innerHTML = '';
  files.forEach((f, i)=>{
    const d = document.createElement('div');
    d.className = 'thumb' + (i===activeIndex ? ' active':'');
    const im = document.createElement('img');
    im.src = f.url;
    const close = document.createElement('div');
    close.className='close';
    close.textContent='×';
    close.title='删除此图';
    close.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeAt(i); });
    d.appendChild(im);
    d.appendChild(close);
    d.addEventListener('click', ()=> setActive(i));
    d.addEventListener('contextmenu', (e)=>{ e.preventDefault(); removeAt(i); });
    // 禁止在缩略图区域投放，避免误拖重复添加
    d.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
    d.addEventListener('drop', (e)=>{ e.preventDefault(); });
    thumbs.appendChild(d);
  });
}

function keyOfFile(f){
  return [f.name, f.size, f.type, f.lastModified].join('|');
}

function addFiles(blobs, makeActiveLatest=false){
  const added = [];
  for(const f of blobs){
    const key = keyOfFile(f);
    if(addedKeys.has(key)) continue;
    if(!/^image\//.test(f.type)) continue;
    const url = URL.createObjectURL(f);
    files.push({file:f, url, key, cropState:null});
    addedKeys.add(key);
    added.push(files.length-1);
  }
  if(files.length>0 && activeIndex<0) activeIndex = 0;
  renderThumbs();
  if(makeActiveLatest && added.length){
    setActive(added[added.length-1]);
  }else if(files.length>0){
    setActive(activeIndex);
  }
}

function removeAt(i){
  const it = files[i];
  if(!it) return;
  URL.revokeObjectURL(it.url);
  addedKeys.delete(it.key);
  files.splice(i,1);
  if(activeIndex>=files.length) activeIndex = files.length-1;
  renderThumbs();
  if(files.length>0) setActive(Math.max(0, activeIndex));
  else {
    if (cropper) { cropper.destroy(); cropper = null; }
    previewImg.removeAttribute('src');
    activeIndex = -1;
  }
}

// 保存当前活动图片的裁剪状态
function saveCurrentCropState(){
  if (activeIndex<0 || !cropper) return;
  const item = files[activeIndex];
  try{
    item.cropState = {
      data: cropper.getData(true),
      cropBox: cropper.getCropBoxData(),
      canvas: cropper.getCanvasData()
    };
  }catch(e){ /* ignore */}
}

// 设置活动图片，并在就绪后恢复裁剪状态（如有）
// 返回 Promise，等裁剪器 ready 且状态恢复完成再 resolve
function setActive(i){
  activeIndex = i;
  renderThumbs();
  if (cropper) { 
    // 离开前保存旧的裁剪状态
    saveCurrentCropState();
    cropper.destroy(); 
    cropper = null; 
  }
  const item = files[i];
  if(!item) return Promise.resolve();
  previewImg.src = item.url;
  return new Promise((resolve)=>{
    previewImg.onload = ()=>{
      cropper = new Cropper(previewImg, {
        aspectRatio: parseFloat(ratioSel.value),
        viewMode: 1,
        autoCropArea: 1,
        background: false,
        ready(){
          // ready 后恢复之前保存的裁剪状态
          if(item.cropState){
            try{
              if(item.cropState.canvas) cropper.setCanvasData(item.cropState.canvas);
              if(item.cropState.cropBox) cropper.setCropBoxData(item.cropState.cropBox);
              if(item.cropState.data)     cropper.setData(item.cropState.data);
            }catch(e){ /* ignore */}
          }
          // 绑定事件：任何调整都实时保存
          bindCropperEvents();
          resolve();
        }
      });
    };
  });
}

function bindCropperEvents(){
  if(!cropper) return;
  const save = ()=> saveCurrentCropState();
  cropper.off('cropend'); cropper.off('zoom'); cropper.off('move'); cropper.off('crop');
  cropper.on('cropend', save);
  cropper.on('zoom', save);
  cropper.on('move', save);
  cropper.on('crop', save);
}

function parseSize(v){
  const m = v.trim().toLowerCase().match(/^(\d+)\s*x\s*(\d+)$/);
  if (!m) return null;
  return {w: parseInt(m[1]), h: parseInt(m[2])};
}

// ------- Export helpers -------
async function canvasToJpegBlob(cropper, size, quality){
  const canvas = cropper.getCroppedCanvas({ width:size.w, height:size.h });
  return await new Promise(res=> canvas.toBlob(res, 'image/jpeg', quality));
}

async function ensureSubdir(handle, subdir){
  try{
    return await handle.getDirectoryHandle(subdir, {create:true});
  }catch(e){ console.error(e); return null; }
}

async function saveBlobToFS(dir, filename, blob){
  const f = await dir.getFileHandle(filename, {create:true});
  const w = await f.createWritable();
  await w.write(blob);
  await w.close();
}

// ------- Actions -------
async function exportCurrent(toFS=true){
  if (activeIndex<0 || !cropper) { showToast('请先选择一张图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size) { showToast('输出尺寸格式不正确'); return; }
  const q = Math.max(0.5, Math.min(1, parseFloat(qualityInput.value)||0.9));
  const spu = (spuInput.value.trim() || 'spu').replace(/[^\w\-]/g,'');
  const baseIndex = parseInt(startIndexInput.value)||1;
  const idx = baseIndex + activeIndex;
  const suffix = suffixInput.value || '_auto';
  const name = `${spu}-${String(idx).padStart(2,'0')}${suffix}.jpg`;

  // 导出前确保保存最新裁剪状态
  saveCurrentCropState();

  const blob = await canvasToJpegBlob(cropper, size, q);

  // 优先写入文件夹（需 https/localhost）
  if(toFS && dirHandle?.kind === 'directory'){
    try{
      const sub = await ensureSubdir(dirHandle, spu);
      if(sub){
        await saveBlobToFS(sub, name, blob);
        return { ok:true, filename:name, path:`${spu}/${name}`, method:'fs' };
      }
    }catch(e){
      console.warn('FS save failed, fallback to download', e);
    }
  }
  // 回退：浏览器下载
  const a = document.createElement('a');
  a.download = name;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  return { ok:true, filename:name, method:'download' };
}

async function exportAll(){
  if (files.length===0){ showToast('请先选择图片'); return; }
  const size = parseSize(sizeInput.value);
  if (!size){ showToast('输出尺寸格式不正确'); return; }
  savePrefs();

  // 记录当前活动索引
  const originalActive = activeIndex;

  for (let i=0;i<files.length;i++){
    if (i === activeIndex && cropper){
      // 当前这张：不要调用 setActive，直接按当前裁剪状态导出
      await exportCurrent(true);
    } else {
      // 其它图片：切换到该图，并恢复其最后一次裁剪状态，再导出
      await setActive(i);
      await exportCurrent(true);
    }
    // 小延时，避免阻塞 UI
    await new Promise(r=> setTimeout(r, 60));
  }

  showToast('全部保存完成 ✅');
  clearAll();
}

function clearAll(){
  if (cropper) { cropper.destroy(); cropper = null; }
  files.forEach(f=> URL.revokeObjectURL(f.url));
  files = []; activeIndex=-1; renderThumbs(); previewImg.removeAttribute('src');
  addedKeys.clear();
}

// ------- Events -------
fileInput.addEventListener('change', e=>{
  addFiles(Array.from(e.target.files));
});

ratioSel.addEventListener('change', ()=>{
  if (cropper){
    // 切换比例：先保存当前裁剪状态，再改变比例，再尝试恢复
    saveCurrentCropState();
    cropper.setAspectRatio(parseFloat(ratioSel.value));
    // 恢复时可能会被约束到新的比例，尽量接近原位置
    const st = files[activeIndex]?.cropState;
    if (st){
      try{
        cropper.setCanvasData(st.canvas);
        cropper.setData(st.data);
      }catch(e){/* ignore */}
    }
  }
  // 尺寸联动：切换比例时，若用户未自定义过，回填默认
  if(ratioSel.value==='0.75' && !localStorage.getItem(LAST_SIZE_075)){
    sizeInput.value = '1500x2000';
  }else if(ratioSel.value==='1' && !localStorage.getItem(LAST_SIZE_1)){
    sizeInput.value = '1200x1200';
  }else{
    const key = ratioSel.value==='1'?LAST_SIZE_1:LAST_SIZE_075;
    const saved = localStorage.getItem(key);
    if(saved) sizeInput.value = saved;
  }
});

el('exportOne').addEventListener('click', ()=> exportCurrent(true).then(()=>showToast('已保存当前')));
el('exportAll').addEventListener('click', exportAll);
el('clear').addEventListener('click', clearAll);

// 预览右键删除当前
previewImg.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  if(activeIndex>=0) removeAt(activeIndex);
});

// 整页拖拽支持
document.addEventListener('dragover', e=>{ e.preventDefault(); });
document.addEventListener('drop', async e=>{
  e.preventDefault();
  const dt = e.dataTransfer;
  if (!dt) return;
  if (dt.files && dt.files.length){
    const imgs = Array.from(dt.files).filter(f=>/^image\//.test(f.type));
    const dropInPreview = e.composedPath().includes(canvasWrap);
    addFiles(imgs, dropInPreview);
    return;
  }
  const url = dt.getData('text/uri-list') || dt.getData('text/plain');
  if(url){
    try{
      const res = await fetch(url, {mode:'cors'});
      const blob = await res.blob();
      if(!/^image\//.test(blob.type)) throw new Error('Not image');
      const f = new File([blob], 'remote.jpg', {type: blob.type});
      const dropInPreview = e.composedPath().includes(canvasWrap);
      addFiles([f], dropInPreview);
    }catch(err){
      showToast('跨域受限，无法直接获取；请先另存图片到本地后再拖入。');
    }
  }
});

// 缩略图容器整体禁投放
thumbs.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='none'; });
thumbs.addEventListener('drop', (e)=>{ e.preventDefault(); });

// 键盘：Ctrl+Enter = Save all
document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
    exportAll();
  }
});

// 选择 Base 文件夹（File System Access API）
// 这里保留按钮但不做 IndexedDB 持久化，专注本次 bug 修复；需要可再加回
el('pickFolder').addEventListener('click', async ()=>{
  if (!('showDirectoryPicker' in window)){
    showToast('当前环境不支持文件夹写入（需 https 或 localhost）');
    return;
  }
  try{
    dirHandle = await window.showDirectoryPicker({id:'tmpicup-base'});
    folderPath.textContent = '已选择';
    showToast('已选择 Base 文件夹');
  }catch(e){
    if(e.name!=='AbortError') showToast('选择文件夹失败');
  }
});

// 保存用户偏好：比例/尺寸
sizeInput.addEventListener('change', savePrefs);
ratioSel.addEventListener('change', savePrefs);
</script>
</body>
</html>
